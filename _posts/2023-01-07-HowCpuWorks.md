---
title: How Cpu Works
tags: ComputerArchitecture
comments: true
---

# ALU와 제어장치

> CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치이다. <br>
> CPU 내부에는 계산을 담당하는 ALU, 명령어를 읽어들이고 해석하는 제어장치, 작은 임시 저장 장치인 레지스터라는 구성 요소가 있다. <br>

<br>

## ALU

<img width="595" alt="7" src="https://github.com/MALLLAG/TIL/assets/87420630/9b6f278c-1356-46f6-b864-b54d4dbc1017">

> ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다. <br>
> ALU는 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행한다. <br>
> 연산을 수행한 결과는 숫자나 문자, 메모리 주소가 될 수 있다. 그리고 이 결과값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다. <br>
> CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느리기 때문에 결과값을 메모리가 아닌 레지스터에 우선 저장한다. <br>

> ALU는 계산 결과와 더불어 플래그를 내보낸다. <br>
> 예를 들어 연산 결과가 음수일 때 ALU는 '방금 계산한 결과가 음수'라는 추가 정보를 내보낸다. <br>
> 혹은 연산 결과가 연산 결과를 담을 레지스터보다 클 때 ALU는 ‘결괏값이 너무 크다’라는 추가 정보를 내보낸다. <br>
> 이러한 연산 결과에 대한 추가적인 상태 정보를 '플래그'라고 한다.

<br>
<hr>

## 제어장치

<img width="780" alt="8" src="https://github.com/MALLLAG/TIL/assets/87420630/c6e068bb-241f-462f-bd65-f2088cb65e6e">

<br>

### 제어장치는 클럭 신호를 받아들인다

> '클럭'이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위이다. <br>
> 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들인다. <br>

### 제어장치는 해석해야 할 명령어를 받아들인다

> CPU가 해석해야 할 명령어는 '명령어 레지스터'라는 특별한 레지스터에 저장된다. <br>
> 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

### 제어장치는 플래그 레지스터 속 플래그 값을 받아들인다

> 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

### 제어장치는 시스템 버스, 그 중 제어 버스로 전달된 제어 신호를 받아들인다

> 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. <br>
> 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들인다.

<br>

### 제어장치는 CPU 외부에 제어 신호를 전달한다

> CPU 외부에 제어 신호를 전달한다는 말은, 제어 버스로 제어 신호를 보낸다는 말이다. <br>
> 이러한 제어 신호에는 크게 메모리에 전달하는 신호와 입출력장치에 전달하는 신호가 있다. <br>
> 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리로 제어 신호를 내보낸다. <br>
> 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶을 때는 입출력장치로 제어 신호를 내보낸다.

### 제어장치는 CPU 내부에 제어 신호를 전달한다

> CPU 내부에 전달하는 제어 신호에는 크게 ALU에 전달하는 신호와 레지스터에 전달하는 신호가 있다. <br>
> ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동시키거나 레지서트에 저장된 명령어를 해석하기 위해 신호를 보낸다.



<br>
<hr>


# 레지스터

> 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다. <br>

<br>

## 알아야 할 레지스터

- 프로그램 카운터
- 명령어 레지스터
- 메모리 주소 레지스터
- 메모리 버퍼 레지스터
- 플래그 레지스터
- 범용 레지스터
- 스택 포인터
- 베이스 레지스터

### 프로그램 카운터

> 메모리에서 가져올 주소를 저장한다. <br>
> 프로그램 카운터를 명령어 포인터라고 부르는 CPU도 있다

### 명령어 레지스터

> 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. <br>
> 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

### 메모리 주소 레지스터

> 메모리의 주소를 저장하는 레지스터이다. <br>
> CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다

### 메모리 버퍼 레지스터

> 메모리와 주고 받을 값(데이터, 명령어)를 저장하는 레지스터 <br>
> 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거치게 된다.

### 범용 레지스터

> 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터 <br>
> 데이터와 주소를 모두 저장할 수 있다

### 플래그 레지스터

> 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장한다.


<br>
<hr>


# 명령어 사이클과 인터럽트

> CPU가 하나의 명령어를 처리하는 과정에는 어떠한 흐름이 있고, CPU는 그 흐름을 반복하며 명령어들을 처리해 나간다. <br>
> 이렇게 하나의 명령어를 처리하는 정형화된 흐름을 '명령어 사이클'이라고 한다. <br>
> 간혹 이 흐름이 끊어지는 상황이 발생하는데, 이를 '인터럽트'라고 한다

<br>

## 명령어 사이클

> CPU가 명령어들을 하나씩 실행할 때, 각각의 명령어들은 일정한 주기가 반복되며 실행되는데 이 주기를 '명령어 사이클'이라고 한다.

<br>

### 인출 사이클

> 메모리에 있는 명령어를 CPU로 가져오는 단계를 '인출 사이클'이라고 한다.

### 실행 사이클

> CPU로 명령어를 인출했다면 이제 명령어를 실행하는데, 이 단계를 '실행 사이클'이라고 한다.

### 간접 사이클

> 명령어를 인출하여 CPU로 가져왔다 하더라도 곧바로 실행할 수 없는 경우도 있다. <br>
> 예를 들어 간접 주소 지정 방식의 경우 오퍼랜드 필드에 유효 주소의 주소를 명시하는데, 이 경우 명령어를 인출했다고 하더라도 바로 실행 사이클에 들어갈 수 없다. <br>
> 이런 경우 명령어를 실행하기 위해 메모리 접근을 한번 더 해야 하는데, 이 단계를 '간접 사이클'이라고 한다.

<br>

## 인터럽트

> CPU가 수행중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이를 '인터럽트'라고 한다. <br>
> 인터럽트 종류에는 크게 '동기 인터럽트'와 '비동기 인터럽트'가 있다

<br>

### 동기 인터럽트 (예외)

> 동기 인터럽트는 CPU에 의해 발생하는 인터럽트이다. <br>
> 가령 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을때 발생하는 인터럽트가 동기 인터럽트이다. <br>
> 이런 점에서 동기 인터럽트는 '예외'라고 부른다

### 비동기 인터럽트 (하드웨어 인터럽트)

> 주로 입출력 장치에 의해 발생하는 인터럽트이다. <br>
> 입출력 장치에 의한 인터럽트는 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 역할을 한다. <br>
> 일반적으로 비동기 인터럽트를 인터럽트, 하드웨어 인터럽트로 칭하기도 한다. <br>
> 하드웨어 인터럽트 처리 순서는 다음과 같다.

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해둔 작업을 복구하여 실행을 재개한다.














