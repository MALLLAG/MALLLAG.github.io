---
title: Cpu Performance Improvement Techniques
tags: ComputerArchitecture
comments: true
---

# 빠른 CPU를 위한 설계 기법

## 클럭

- 컴퓨터 부품들은 '클럭 신호'에 맞춰 일사불란하게 움직인다.
- CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어들을 실행한다.

> 클럭 신호가 빠르게 반복되면 CPU를 비롯한 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰 움직인다. <br>
> 실제로 클럭 속도가 높은 CPU들은 일반적으로 성능이 좋다


<br>
<hr>


## 코어와 멀티코어

> CPU의 정의로 알고 있던 '명령어를 실행하는 부품'은 오늘날 '코어'라는 용어로 사용된다.
> 8코어는 명령어를 실행하는 부품이 8개 포함되어 있는 것. <br>
> 하지만 CPU의 연산 속도가 꼭 코어 수에 비례해서 증가하지는 않는다. <br>
> 중요한 것은 코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐 이다.

<br>

<img width="721" alt="9" src="https://github.com/MALLLAG/TIL/assets/87420630/aafd7d3d-d568-4b8c-89b5-740f7a4e9a66">


<br>
<hr>



## 스레드와 멀티스레드

> 스레드에는 CPU에서 사용되는 '하드웨어적 스레드'가 있고 <br>
> 프로그램에서 사용되는 '소프트웨어적 스레드'가 있다.

<br>

### 하드웨어적 스레드

> 스레드를 하드웨어적으로 정의하면 '하나의 코어가 동시에 처리하는 명령어 단위' <br>
> 여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있다. <br>
> 예를 들어 2코어 4스레드 CPU는 명령어를 실행하는 부품이 두개이고, 한 번에 네 개의 명령어를 처리할 수 있다. <br>
> 이처럼 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 '멀티스레드 프로세서' 혹은 '멀티스레드 CPU'라고 한다.


<br>

### 소프트웨어적 스레드

> 소프트웨어적으로 정의된 스레드는 '하나의 프로그램에서 독립적으로 실행되는 단위'

<br>

<img width="594" alt="10" src="https://github.com/MALLLAG/TIL/assets/87420630/74273b05-69ed-4e35-8fef-e59566883cf3">


<br>
<hr>


## 멀티스레드 프로세서

> 멀티스레드 프로세서를 설계하는데 핵심은 레지스터이다. <br>
> 하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, <br>
> 데이터 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러 개 가지고 있으면 된다.


<br>
<br>


# 명령어 병렬 처리 기법

> 빠른 CPU를 만들려면 CPU가 놀지 않고 시간을 효율적으로 쓰며 작동하게 만드는것도 중요하다. <br>
> 명령어를 동시에 처리하며 CPU를 쉬지 않게 하는 기법인 '명령어 병렬 처리 기법'이 있고, <br>
> 이 중에는 '명령어 파이프 라이닝', '슈퍼스칼라', '비순차적 명령어 처리'가 있다.

<br>

## 명령어 파이프라인

명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 다음과 같이 나눌 수 있다.
여기서 중요한 점은 같은 단계가 겹치지만 않으면 CPU는 각 단계를 동시에 실행할 수 있다.

- 명령어 인출
- 명령어 해석
- 명령어 실행
- 결과 저장

<img width="521" alt="11" src="https://github.com/MALLLAG/TIL/assets/87420630/3d6e5bd7-38c2-4f78-8ddf-1c241c942bd4">

<br>

<p>파이프라이닝이 높은 성능을 가져오긴 하지만 특정 상황에서는 성능 향상에 실패할 수 있다.</p>

<br>

### 데이터 위험

'데이터 위험'은 명령어 간 데이터 의존성에 의해 발생한다.

```text
명령어 1 : R1 <- R2 + R3    // R2 레지스터 값과 R3 레지스터 값을 더한 값을 R1 레지스터에 저장
명령어 2 : R4 <- R1 + R5    // R1 레지스터 값과 R5 레지스터 값을 더한 값을 R4 레지스터에 저장
```

위의 경우 명령어 1을 수행해야만 명령어 2를 수행할 수 있다. <br>
이처럼 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는데, 이를 ‘데이터 위험’이라고 한다.

<br>

### 제어 위험

'제어 위험'은 주로 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생한다. <br>
이를 위해 사용하는 기술 중 하나가 '분기 예측'

<img width="537" alt="12" src="https://github.com/MALLLAG/TIL/assets/87420630/ef207507-2681-4186-bcd9-f266e7f2fd0f">

<br>

### 구조적 위험

'구조적 위험'은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려 할 때 발생한다.


<br>
<hr>


## 슈퍼스칼라

파이프라이닝은 단일 파이프라인으로도 구현 가능하지만 오늘날 대부분의 CPU는 여러 개의 파이프라인을 이용한다. <br>
이처럼 CPU 내부에 여러 개의 파이프라인을 포함한 구조를 '슈퍼스칼라'라고 한다.

<img width="527" alt="13" src="https://github.com/MALLLAG/TIL/assets/87420630/3a03308b-8802-4137-a3b5-7c52a6616bd1">


<br>
<hr>


## 비순차적 명령어 처리

명령어 파이프라이닝, 슈퍼스칼라는 모두 여러 명령어를 순차적으로 처리하는 방법이다. <br>
'비순차적 명령어 처리'는 순서를 바꿔 처리해도 수행 결과에 영향을 미치지 않는 명령어들을, 순서를 바꿔 먼저 처리한다. <br>
비순차적 명령어 처리가 가능한 CPU는 명령어들이 어떤 명령어와 데이터 의존성을 가지고, <br>
순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지를 판단할 수 있어야 한다.


<br>
<br>


# CISC와 RISC

명령어 파이프라이닝과 슈퍼스칼라 기법을 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 한다. <br>

<br>

## 명령어 집합

CPU가 이해할 수 있는 명령어들의 모음을 `명령어 집합` 또는 `명령어 집합 구조(ISA)`라고 한다. <br>
예를 들어 인텔의 노트북 속 CPU는 x86 혹은 x86-64 ISA를 이해하고, 애플의 아이폰 속 CPU는 ARM ISA를 이해한다. <br>

> 현대 ISA의 양대 산맥에는 CISC와 RISC가 있다

<br>

### CISC (Complex Instruction Set Computer)

CISC란 이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식이다. (x86, x86-64) <br>
다양하고 강력한 기능의 명령어 집합을 활용하기 때문에, `가변 길이 명령어`를 활용한다. (상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.)

CISC의 단점으로는, 활용하는 명령어가 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않다. <br>
그리고 복잡한 명령어 때문에 명령어 하나를 실행하는데 여러 클럭 주기를 필요로 하고, 이는 명령어 파이프라인을 구현하는데 큰 걸림돌이 된다.

CISC의 한계가 주는 교훈은 다음과 같다.
- 원활한 파이프라이닝을 위해 ‘명령어 길이와 수행 시간이 짧고 규격화’되어 있어야 한다.
- 대부분 자주 쓰이는 명령어만 사용된다. 복잡한 기능을 지원하는 명령어를 추가하기보다는 ‘자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것’이 중요하다.

<br>

### RISC (Reduced Instruction Set Computer)

RISC는 이름처럼 명령어의 종류가 적고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다. (고정 길이 명렁어)

그리고 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화한다. <br>
그 대신 레지스터를 적극 활용해서, CISC보다 레지스터를 이용한 연산이 많고, 레지스터 갯수도 많다. <br>
대표적인 RISC 기반의 ISA로 ARM이 있다.


<img width="521" alt="11" src="https://github.com/MALLLAG/TIL/assets/87420630/3d6e5bd7-38c2-4f78-8ddf-1c241c942bd4">

