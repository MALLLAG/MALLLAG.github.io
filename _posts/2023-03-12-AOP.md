---
title: AOP
tags: Spring
comments: true
---

# AOP 개념

- **조인포인트** : 조인포인트는 AOP를 사용해 추가 로직을 삽입할 수 있는 애플리케이션의 특정 지점을 정의된다. 예로는 *메서드의 명시적 호출, 메서드의 참조에 의한 호출, 클래스 초기화, 객체 인스턴스 생성* 등이 있다.
- **어드바이스** : 어드바이스는 특정 조인포인트에 실행되는 코드로, 클래스 내 메서드로 정의된다. 종류로는 *비포 어드바이스, 애프터 어드바이스*가 있다.
- **포인트컷** : 포인트컷은 언제 어드바이스를 실행할지를 정의할 때 사용하는 조인포인트의 모음이다. 포인트컷을 생성하면 애플리케이션의 컴포넌트에 어드바이스를 적용하는 방법을 상세하게 제어할 수 있다.
- **애스펙트** : 애스펙트는 클래스에 캡슐화된 어드바이스와 포인트컷의 조합이다. 이는 애플리케이션에 포함돼야 하는 로직과 로직이 어디서 실행돼야 하는지를 정의한다.
- **위빙** : 위빙은 애플리케이션 코드의 적절한 위치에 애스펙트를 삽입하는 과정을 말한다. 컴파일 시점 AOP 솔루션에서는 일반적으로 위빙은 빌드 시점에 수행된다.
  마찬가지로, 런타임 AOP 솔루션에서는 위빙 과정이 런타임에 동적으로 실행된다.
  AspectJ는 그 외에도 로드 시점 위빙이라는 메커니즘을 제공하는데 이 방식은 내부 JVM 클래스 로더를 클래스 로더가 바이트코드를 로딩할 때 해당 바이트코드에 위빙 기능을 제공한다.
- **대상** : 실행 흐름이 AOP에 의해 수정된 객체를 대상 객체라고 한다.
- **인트로덕션** : 인트로덕션은 추가 메서드나 필드를 도입해 객체의 구조를 수정하는 과정을 말한다.

<br>
<hr>

# AOP의 종류

## 정적 AOP

정적 AOP에서 위빙 프로세스는 애플리케이션 빌드 프로세스에서 별도 단계로 이루어진다. <br>
자바에서는 필요에 따라 애플리케이션의 실제 바이트코드를 수정하고 애플리케이션 코드를 변경 하고 확장하는 방법으로 <br>
정적 AOP 구현체에서 위빙 프로세스를 적용한다.

단점은 애스펙트를 조금이라도 수정하게 되면 전체 애플리케이션을 다시 컴파일해야 한다.

## 동적 AOP

스프링 AOP와 같은 동적 AOP 구현체는 런타임에 동적으로 위빙 프로세스가 수행된다. <br>
구현체에 따라 동적 위빙이 다르긴 하지만, 스프링의 접근 방식은 어드바이스가 적용된 모든 객체에 대한 프록시를 생성해 어드바이스를 호출한다.

단점은 일반적으로 정적 AOP만큼 성능이 좋지 않다.

<br>
<hr>

# 스프링 AOP 아키텍처

스프링 AOP의 핵심 아키텍처는 프록시를 기반으로 한다.

어드바이스를 적용한 클래스 인스턴스를 생성하려면 ProxyFactory를 사용해 해당 클래스의 프록시 인스턴스를 생성하고 먼저 ProxyFactory에 프록시로 위빙하려는 모든 애스펙트를 제공해야 한다. <br>
ProxyFactory를 사용하는 방식은 프로그래밍으로 AOP 프록시를 생성하는 방식으로, 대부분은 이 방식을 사용하지 않고 <br>
스프링이 제공하는 선언적 AOP 구성 매커니즘 (ProxyFactoryBean 클래스, aop 네임스페이스, ©AspectJ 스타일의 애너테이션)을 사용해서 프록시를 생성한다.

스프링은 런타임 시점에 ApplicationContext의 빈엔 정의된 횡단 관심사를 분석하고 프록시 빈을 동적으로 생성한다. <br>
그리고 호출자에 프록시 빈을 주입하고, 프록시 빈은 실행 조건(조인포인트, 포인트컷, 어드바이스 등)을 분석하고 적절한 어드바이스를 위빙한다.

스프링은 내부에 **JDK 동적 프록시**와 **CGLIB 프록시**의 두 가지 프록시 구현체를 가지고 있다. <br>
어드바이스를 적용할 대상 객체가 특정 인터페이스를 구현하면 **JDK 동적 프록시**를 사용해 프록시 인스턴스를 생성하고, (JDK 동적 프록시는 인터페이스 프록시만 지원한다.) <br>
대상 객체가 특정 인터페이스를 구현하지 않으면 **CGLIB**를 사용해 프록시 인스턴스를 생성한다.

## 스프링 조인포인트

스프링 AOP는 메서드 호출 조인포인트만을 지원하고, 그에 따라 다른 AOP 구현체보다 사용하기 쉽다. <br>
만약 메서드 호출 조인포인트 이외의 조인포인트에서 어드바이스를 적용해야 할때는, 스프링 AOP와 AspectJ를 함께 사용하는 방법을 사용할 수 있다.

## 스프링 애스펙트

스프링 AOP에서 애스펙트는 Advisor 인터페이스를 구현한 클래스의 인스턴스이고, Advisor 하위 인터페이스로 PointcutAdvisor와 IntroductionAdvisor가 있다.

포인트컷을 사용해 조인포인트에 적용할 어드바이스를 제어하는 모든 Advisor 구현체는 PointcutAdvisor로 구현하고, <br>
인트로덕션이 적용되는 클래스를 제어하기 위해선 IntroductionAdvisor 인터페이스를 사용한다.

## ProxyFactory 클래스

ProxyFactory 클래스는 스프링 AOP의 위빙과 프록시 생성 과정을 제어한다. <br>
프록시를 생성하기 전에 항상 어드바이스를 적용하는 객체나 대상 객체를 지정해야 하는데, setTarget() 메서드로 이 작업을 수행할 수 있다.

## 어드바이스 만들기

|이름|설명|
|---|---|
|Before|메서드 실행 전에 전처리를 수행할 수 있게 해준다. 메서드에 전달된 인수와 메서드 호출 대상에 접근 권한을 가지지만 메서드 실행을 제어할 수는 없다. 비포 어드바이스가 예외를 던지면 인터셉트 체인의 이후 실행이 중단되고 예외가 인터 셉터 체인을 통해 전달된다.|
|After-Returning|메서드 호출이 실행을 마치고 값을 반환한 후에 실행된다. 메서드 호출 대상, 메서드에 전달된 인수에 접근할 수 있고 메서드 호출을 제어할 수 없다. 대상 메서드가 예외를 던지면 애프터 리터닝 어드바이스는 실행되지 않는다.|
|After(finally)|메서드의 결과와 상관없이 실행된다. (예외가 발생하더라도 실행)|
|Around|메서드 호출 전후에 실행되고, 메서드 호출이 진행되는 시점을 제어할 수 있다.|
|Throws|메서드 호출이 끝난 후 호출이 예외를 던질때만 실행된다. 특정 예외만 잡는것이 가능하고 예외를 던진 메서드, 메서드 호출로 전달된 인수, 호출 대상에 접근할 수 있다.|
|Introduction|스프링은 인트로덕션을 특수한 인터셉터 타입으로 모델링한다. 인트로덕션 인터셉터를 사용하면 어드바이스가 인트로듀스하는 메서드의 구현체를 지정할 수 있다.|

## 어드바이스 인터페이스

프록시에 어드바이스를 추가하는 데는 두 가지 방법이 있다.

1. addAdvice() 메서드로 어드바이스를 직접 추가하는 방법
2. Advisor 구현체를 addAdvice() 메서드에 전달해 간접적으로 추가하는 방법

2번 방법은 관련 포인트컷과 함께 어드바이스를 전달하는데, 이렇게 하면 조인포인트를 좀 더 상세하게 제어할 수 있다.

<img width="704" alt="5" src="https://github.com/MALLLAG/TIL/assets/87420630/45f1d958-e42e-4cf9-a642-f040796d5aa0">

<br>
<hr>

# 프록시

프록시의 핵심 목적은 메서드 호출을 인터셉트하고 필요한 경우 특정 메서드에 적용되는 어드바이스 체인을 실행하는 것이다. <br>
어드바이스의 관리와 호출은 대부분 프록시와 독립적이고 스프링 AOP 프레임워크가 관리한다. <br>
하지만 프록시는 모든 메서드 호출을 인터셉트하고 필요에 따라 어드바이스를 적용할 수 있도록 AOP 프레임워크에 전달할 책임이 있다.

추가로 프록시는 AopContext 클래스로 자신을 외부로 노출하도록 구성해 프록시를 가져오고 대상 객체의 프록시를 사용해 어드바이스가 적용된 메서드를 호출할 수 있다.


## JDK 동적 프록시

JDK 동적 프록시는 클래스가 아닌 인터페이스 프록시만을 생성할 수 있다. <br>
프록시를 적용하는 모든 객체는 적어도 하나의 인터페이스를 구현해야 하고, 결과로 생성되는 프록시는 그 인터페이스를 구현하는 객체가 된다.

<img width="450" alt="6" src="https://github.com/MALLLAG/TIL/assets/87420630/e4e3c1d5-edad-45c1-960a-24d19d386fa1">

> JDK 프록시를 사용하면 JVM이 모든 메서드 호출을 인터셉트해 프록시의 invoke() 메서드로 라우트한다. <br>
> 이후 invoke() 메서드는 호출된 메서드가 어드바이스 적용 대상이라면 어드바이스 체인을 호출한 후에 리플렉션을 사용해 메서드 자체를 호출한다. <br>
> JDK 프록시를 사용하면 특정 메서드 호출을 처리하는 방식에 대한 모든 결정이 런타임에 메서드가 호출될 때마다 이뤄진다.

## CGLIB 프록시

CGLIB는 각 프록시에 대해 동적으로 새 클래스에 대한 바이트코드를 생성하고, 이미 생성된 클래스를 사용할 수 있으면 재사용한다. <br>
이때 프록시 타입은 대상 객체 클래스의 하위 클래스가 된다.

<img width="365" alt="7" src="https://github.com/MALLLAG/TIL/assets/87420630/d0871c22-df5f-4115-86b8-caed8896d1eb">

CGLIB 프록시가 처음 생성될때 각 메서드를 어떻게 처리할지 스프링에 물어본다. <br>
CGLIB는 실제 바이트코드를 생성하기 때문에 메서드를 더 유연하게 처리할 수 있다.

<br>
<hr>

